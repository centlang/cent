with c;
with std::ffi;

pub type Fd {
    _file: *mut c::FILE,
}

pub fn Fd::close(self: Fd) {
    c::fclose(self._file);
}

#(alwaysinline)
pub fn printf(fmt: []u8, args: []WriteArg) {
    writef(stdout(), fmt, args);
}

#(alwaysinline)
pub fn eprintf(fmt: []u8, args: []WriteArg) {
    writef(stderr(), fmt, args);
}

#(alwaysinline)
pub fn print_rune(value: rune) {
    write_rune(stdout(), value);
}

#(alwaysinline)
pub fn eprint_rune(value: rune) {
    write_rune(stderr(), value);
}

#(alwaysinline)
pub fn print_uint(value: u64) {
    write_uint(stdout(), value);
}

#(alwaysinline)
pub fn eprint_uint(value: u64) {
    write_uint(stderr(), value);
}

#(alwaysinline)
pub fn print_int(value: i64) {
    write_int(stdout(), value);
}

#(alwaysinline)
pub fn eprint_int(value: i64) {
    write_int(stderr(), value);
}

#(alwaysinline)
pub fn print_float(value: f64) {
    write_float(stdout(), value);
}

#(alwaysinline)
pub fn eprint_float(value: f64) {
    write_float(stderr(), value);
}

#(alwaysinline)
pub fn print(str: []u8) {
    write(stdout(), str);
}

#(alwaysinline)
pub fn eprint(str: []u8) {
    write(stderr(), str);
}

#(alwaysinline)
pub fn println(str: []u8) {
    writeln(stdout(), str);
}

#(alwaysinline)
pub fn eprintln(str: []u8) {
    writeln(stderr(), str);
}

#(alwaysinline)
pub fn input_line_to(buf: []mut u8) ?[]mut u8 {
    return read_line_to(stdin(), buf);
}

#(alwaysinline)
pub fn input_uint() ?u64 {
    return read_uint(stdin());
}

#(alwaysinline)
pub fn input_int() ?i64 {
    return read_int(stdin());
}

pub union WriteArg {
    float: f64,
    int: i64,
    uint: u64,
    bool: bool,
    str: []u8,
    rune: rune,
}

fn write_arg(fd: Fd, arg: WriteArg) {
    switch arg {
        WriteArg::float { write_float(fd, arg.float); }
        WriteArg::int { write_int(fd, arg.int); }
        WriteArg::uint { write_uint(fd, arg.uint); }
        WriteArg::str { write(fd, arg.str); }
        WriteArg::rune { write_rune(fd, arg.rune); }
        WriteArg::bool {
            if arg.bool {
                write(fd, "true");
            } else {
                write(fd, "false");
            };
        }
        else { unreachable; }
    }
}

pub fn writef(fd: Fd, fmt: []u8, args: []WriteArg) bool {
    mut p: usize = 0;
    mut arg: usize = 0;

    while p < fmt.len {
        if fmt[p] == '{' as u8 {
            p += 1;

            if p == fmt.len {
                return false;
            }

            if fmt[p] == '{' as u8 {
                write_u8(fd, '{' as u8);
                p += 1;

                continue;
            }

            if fmt[p] != '}' as u8 {
                return false;
            }

            p += 1;

            if arg == args.len {
                return false;
            }

            write_arg(fd, args[arg]);
            arg += 1;

            continue;
        }

        if fmt[p] == '}' as u8 {
            p += 1;

            if p == fmt.len || fmt[p] != '}' as u8 {
                return false;
            }

            write_u8(fd, '}' as u8);
            p += 1;

            continue;
        }

        write_u8(fd, fmt[p]);
        p += 1;
    }

    return true;
}

pub fn write_u8(fd: Fd, byte: u8) {
    c::fputc(byte as c::int, fd._file);
}

pub fn write(fd: Fd, data: []u8) {
    c::fwrite(&data[0] as *c::void, 1, data.len, fd._file);
}

pub fn writeln(fd: Fd, data: []u8) {
    write(fd, data);
    write_u8(fd, '\n' as u8);
}

pub fn write_rune(fd: Fd, value: rune) {
    let r = value as u32;

    if r > 0x10ffff || (r >= 0xd800 && r <= 0xdfff) {
        return;
    }

    if r <= 0x7f {
        write_u8(fd, (r) as u8);
        return;
    }

    if r <= 0x7ff {
        write_u8(fd, (0xc0 | (r >> 6)) as u8);
        write_u8(fd, (0x80 | (r & 0x3f)) as u8);
        return;
    }

    if r <= 0xffff {
        write_u8(fd, (0xe0 | (r >> 12)) as u8);
        write_u8(fd, (0x80 | ((r >> 6) & 0x3f)) as u8);
        write_u8(fd, (0x80 | (r & 0x3f)) as u8);
        return;
    }

    write_u8(fd, (0xf0 | (r >> 18)) as u8);
    write_u8(fd, (0x80 | ((r >> 12) & 0x3f)) as u8);
    write_u8(fd, (0x80 | ((r >> 6) & 0x3f)) as u8);
    write_u8(fd, (0x80 | (r & 0x3f)) as u8);
}

pub fn write_uint(fd: Fd, mut value: u64) {
    mut buf: [20]u8 = undefined;
    mut i: usize;

    if value == 0 {
        write_u8(fd, '0' as u8);
        return;
    }

    while value > 0 {
        buf[i] = ('0' as u8 + (value % 10) as u8);

        value /= 10;
        i += 1;
    }

    while i > 0 {
        write_u8(fd, buf[i - 1] as u8);
        i -= 1;
    }
}

pub fn write_int(fd: Fd, value: i64) {
    if value < 0 {
        write_u8(fd, '-' as u8);
        write_uint(fd, (-(value + 1) + 1) as u64);
        return;
    }

    write_uint(fd, value as u64);
}

pub fn write_float(fd: Fd, mut value: f64, precision: u8 = 6) {
    if value < 0 {
        write_u8(fd, '-' as u8);
        value = -value;
    }

    mut int = value as u64;
    mut scale: u64 = 1;

    for _ in 0..precision {
        scale *= 10;
    }

    mut fract = ((value - int) * scale + 0.5) as u64;

    if fract >= scale {
        int += 1;
        fract = 0;
    }

    write_uint(fd, int);

    if precision == 0 {
        return;
    }

    write_u8(fd, '.' as u8);

    mut n = fract;
    mut fract_digits: u8 = 0;

    if n == 0 {
        fract_digits = 1;
    }

    while n > 0 {
        n /= 10;
        fract_digits += 1;
    }

    let zeros = precision - fract_digits;

    for _ in 0..zeros {
        write_u8(fd, '0' as u8);
    }

    write_uint(fd, fract);
}

pub fn read_u8(fd: Fd) ?u8 {
    let c = c::fgetc(fd._file);

    if c == c::EOF {
        return null;
    }

    return c as u8;
}

pub fn read_line_to(fd: Fd, data: []mut u8) ?[]mut u8 {
    for i in 0..data.len {
        let c = read_u8(fd);

        if c == null {
            return data[:i];
        }

        let c = c.! as u8;

        if c == '\n' as u8 {
            return data[:i];
        }

        data[i] = c;
    }

    return null;
}

pub fn read_uint(fd: Fd) ?u64 {
    mut r: u64 = undefined;

    if c::fscanf(fd._file, ffi::as_cstr("%llu\0"), &r) != 1 {
        return null;
    }

    return r;
}

pub fn read_int(fd: Fd) ?i64 {
    mut r: i64 = undefined;

    if c::fscanf(fd._file, ffi::as_cstr("%lli\0"), &r) != 1 {
        return null;
    }

    return r;
}

pub fn stdout() Fd {
    return Fd { _file: c::stdout };
}

pub fn stdin() Fd {
    return Fd { _file: c::stdin };
}

pub fn stderr() Fd {
    return Fd { _file: c::stderr };
}
